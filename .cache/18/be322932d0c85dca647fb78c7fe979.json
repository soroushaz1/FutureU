{"id":"node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js","dependencies":[{"name":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Shaders\\gpuUpdateParticles.vertex.js.map","includedInParent":true,"mtime":1704105649448},{"name":"F:\\FutureU\\babylonjs\\package.json","includedInParent":true,"mtime":1704105536080},{"name":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\package.json","includedInParent":true,"mtime":1704105648327},{"name":"../Engines/shaderStore.js","loc":{"line":2,"column":28,"index":44},"parent":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Shaders\\gpuUpdateParticles.vertex.js","resolved":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Engines\\shaderStore.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gpuUpdateParticlesVertexShader = void 0;\nvar _shaderStore = require(\"../Engines/shaderStore.js\");\n// Do not edit.\n\nconst name = \"gpuUpdateParticlesVertexShader\";\nconst shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;\nuniform float timeDelta;\nuniform float stopFactor;\n#ifndef LOCAL\nuniform mat4 emitterWM;\n#endif\nuniform vec2 lifeTime;\nuniform vec2 emitPower;\nuniform vec2 sizeRange;\nuniform vec4 scaleRange;\n#ifndef COLORGRADIENTS\nuniform vec4 color1;\nuniform vec4 color2;\n#endif\nuniform vec3 gravity;\nuniform sampler2D randomSampler;\nuniform sampler2D randomSampler2;\nuniform vec4 angleRange;\n#ifdef BOXEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\nuniform vec3 minEmitBox;\nuniform vec3 maxEmitBox;\n#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\nuniform float radiusRange;\nuniform float directionRandomizer;\n#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\nuniform float radiusRange;\n#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\nuniform float height;\nuniform float radiusRange;\n#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\nuniform float coneAngle;\nuniform vec2 height;\nuniform float directionRandomizer;\n#endif\nin vec3 position;\n#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\n#endif\nin float age;\nin float life;\nin vec4 seed;\nin vec3 size;\n#ifndef COLORGRADIENTS\nin vec4 color;\n#endif\nin vec3 direction;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\n#else\nin vec2 angle;\n#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\nin vec3 noiseCoordinates2;\n#endif\nout vec3 outPosition;\n#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\n#endif\nout float outAge;\nout float outLife;\nout vec4 outSeed;\nout vec3 outSize;\n#ifndef COLORGRADIENTS\nout vec4 outColor;\n#endif\nout vec3 outDirection;\n#ifndef BILLBOARD\nout vec3 outInitialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\n#else\nout vec2 outAngle;\n#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\nout vec3 outNoiseCoordinates2;\n#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\n#endif \n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\nuniform float limitVelocityDamping;\n#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\n#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\nuniform sampler2D noiseSampler;\n#endif\n#ifdef ANIMATESHEET\nuniform vec4 cellInfos;\n#endif\nvec3 getRandomVec3(float offset) {\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\n}\nvec4 getRandomVec4(float offset) {\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\n}\nvoid main() {\nfloat newAge=age+timeDelta; \nif (newAge>=life && stopFactor != 0.) {\nvec3 newPosition;\nvec3 newDirection;\nvec4 randoms=getRandomVec4(seed.x);\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\noutAge=newAge-life;\noutSeed=seed;\n#ifdef SIZEGRADIENTS \noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\n#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\n#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \n#ifndef COLORGRADIENTS\noutColor=color1+(color2-color1)*randoms.b;\n#endif\n#ifndef ANGULARSPEEDGRADIENTS \noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#endif \n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=vec3(0,0,0);\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\nnewDirection=direction1+(direction2-direction1)*randoms3; \n#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\nnewDirection=newPosition+directionRandomizer*randoms3; \n#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\n#else\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\n#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nfloat yPos=(randoms2.x-0.5)*height;\nfloat angle=randoms2.y*PI*2.;\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\nfloat xPos=positionRadius*cos(angle);\nfloat zPos=positionRadius*sin(angle);\nnewPosition=vec3(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;\nnewDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));\nnewDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nfloat s=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\n#else\nfloat h=randoms2.y*height.y;\nh=1.-h*h; \n#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\nlRadius=lRadius*h;\nfloat randX=lRadius*sin(s);\nfloat randZ=lRadius*cos(s);\nfloat randY=h *height.x;\nnewPosition=vec3(randX,randY,randZ); \nif (abs(cos(coneAngle))==1.0) {\nnewDirection=vec3(0.,1.0,0.);\n} else {\nvec3 randoms3=getRandomVec3(seed.z);\nnewDirection=normalize(newPosition+directionRandomizer*randoms3); \n}\n#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\noutInitialPosition=initialPosition;\n#else \nnewPosition=vec3(0.,0.,0.);\nnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\n#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\n#ifdef LOCAL\noutPosition=newPosition;\n#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#ifndef BILLBOARD \noutInitialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\n#else \nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\n#endif\noutDirection=initial*power;\n#ifndef BILLBOARD \noutInitialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET \noutCellIndex=cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\n#endif \n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n} else {\nfloat directionScale=timeDelta;\noutAge=newAge;\nfloat ageGradient=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient; \noutInitialPosition=initialPosition;\n#else\noutPosition=position+direction*directionScale;\n#endif\noutLife=life;\noutSeed=seed;\n#ifndef COLORGRADIENTS \noutColor=color;\n#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\noutSize.yz=size.yz;\n#else\noutSize=size;\n#endif \n#ifndef BILLBOARD \noutInitialDirection=initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#else\nvec3 updatedDirection=direction+gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\nfloat currentVelocity=length(updatedDirection);\nif (currentVelocity>limitVelocity) {\nupdatedDirection=updatedDirection*limitVelocityDamping;\n}\n#endif\noutDirection=updatedDirection;\n#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\noutDirection=outDirection+force*timeDelta;\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\noutAngle=angle+angularSpeed*timeDelta;\n#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET \nfloat offsetAge=outAge;\nfloat dist=cellInfos.y-cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\noffsetAge+=cellStartOffset;\n#else\nfloat cellStartOffset=0.;\n#endif \nfloat ratio=0.;\nif (cellInfos.w==1.0) {\nratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\n}\nelse {\nratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);\n}\noutCellIndex=float(int(cellInfos.x+ratio*dist));\n#endif\n}\n}`;\n// Sideeffect\n_shaderStore.ShaderStore.ShadersStore[name] = shader;\n/** @internal */\nconst gpuUpdateParticlesVertexShader = exports.gpuUpdateParticlesVertexShader = {\n  name,\n  shader\n};"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":4}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":16}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":19}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":26}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":10,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":6},"generated":{"line":10,"column":6}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":10},"generated":{"line":10,"column":10}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":10,"column":13}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":45},"generated":{"line":10,"column":45}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":11,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":5,"column":6},"generated":{"line":11,"column":6}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":5,"column":12},"generated":{"line":11,"column":12}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":5,"column":15},"generated":{"line":11,"column":15}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":369,"column":2},"generated":{"line":375,"column":2}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":370,"column":0},"generated":{"line":376,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":0},"generated":{"line":377,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":11},"generated":{"line":377,"column":24}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":12},"generated":{"line":377,"column":25}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":24},"generated":{"line":377,"column":37}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":25},"generated":{"line":377,"column":38}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":29},"generated":{"line":377,"column":42}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":30},"generated":{"line":377,"column":43}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":33},"generated":{"line":377,"column":46}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":371,"column":39},"generated":{"line":377,"column":52}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":372,"column":0},"generated":{"line":378,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":7},"generated":{"line":379,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":13},"generated":{"line":379,"column":6}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":43},"generated":{"line":379,"column":36}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":43},"generated":{"line":379,"column":39}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":43},"generated":{"line":379,"column":46}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":43},"generated":{"line":379,"column":47}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":43},"generated":{"line":379,"column":77}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":46},"generated":{"line":379,"column":80}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":48},"generated":{"line":380,"column":2}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":52},"generated":{"line":380,"column":6}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":54},"generated":{"line":381,"column":2}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":60},"generated":{"line":382,"column":0}},{"source":"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":373,"column":62},"generated":{"line":382,"column":1}}],"sources":{"../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesVertexShader\";\nconst shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;\runiform float timeDelta;\runiform float stopFactor;\r#ifndef LOCAL\nuniform mat4 emitterWM;\r#endif\nuniform vec2 lifeTime;\runiform vec2 emitPower;\runiform vec2 sizeRange;\runiform vec4 scaleRange;\r#ifndef COLORGRADIENTS\nuniform vec4 color1;\runiform vec4 color2;\r#endif\nuniform vec3 gravity;\runiform sampler2D randomSampler;\runiform sampler2D randomSampler2;\runiform vec4 angleRange;\r#ifdef BOXEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\runiform vec3 minEmitBox;\runiform vec3 maxEmitBox;\r#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\runiform float radiusRange;\runiform float directionRandomizer;\r#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\runiform float radiusRange;\r#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\runiform float height;\runiform float radiusRange;\r#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\runiform float coneAngle;\runiform vec2 height;\runiform float directionRandomizer;\r#endif\nin vec3 position;\r#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\r#endif\nin float age;\rin float life;\rin vec4 seed;\rin vec3 size;\r#ifndef COLORGRADIENTS\nin vec4 color;\r#endif\nin vec3 direction;\r#ifndef BILLBOARD\nin vec3 initialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\r#else\nin vec2 angle;\r#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\rin vec3 noiseCoordinates2;\r#endif\nout vec3 outPosition;\r#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\r#endif\nout float outAge;\rout float outLife;\rout vec4 outSeed;\rout vec3 outSize;\r#ifndef COLORGRADIENTS\nout vec4 outColor;\r#endif\nout vec3 outDirection;\r#ifndef BILLBOARD\nout vec3 outInitialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\r#else\nout vec2 outAngle;\r#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\rout vec3 outNoiseCoordinates2;\r#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\r#endif \n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\r#endif \n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\r#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\runiform float limitVelocityDamping;\r#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\r#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\runiform sampler2D noiseSampler;\r#endif\n#ifdef ANIMATESHEET\nuniform vec4 cellInfos;\r#endif\nvec3 getRandomVec3(float offset) {\rreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\r}\rvec4 getRandomVec4(float offset) {\rreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\r}\rvoid main() {\rfloat newAge=age+timeDelta; \rif (newAge>=life && stopFactor != 0.) {\rvec3 newPosition;\rvec3 newDirection;\rvec4 randoms=getRandomVec4(seed.x);\routLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\routAge=newAge-life;\routSeed=seed;\r#ifdef SIZEGRADIENTS \noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\r#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\r#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\routSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \r#ifndef COLORGRADIENTS\noutColor=color1+(color2-color1)*randoms.b;\r#endif\n#ifndef ANGULARSPEEDGRADIENTS \noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\routAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#endif \n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=vec3(0,0,0);\rnewDirection=direction1+(direction2-direction1)*randoms3;\r#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\rnewDirection=direction1+(direction2-direction1)*randoms3; \r#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\rnewDirection=newPosition+directionRandomizer*randoms3; \r#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\r#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\r#else\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\r#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat yPos=(randoms2.x-0.5)*height;\rfloat angle=randoms2.y*PI*2.;\rfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\rfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\rfloat xPos=positionRadius*cos(angle);\rfloat zPos=positionRadius*sin(angle);\rnewPosition=vec3(xPos,yPos,zPos);\r#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\r#else\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;\rnewDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));\rnewDirection=normalize(newDirection);\r#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rfloat s=2.0*PI*randoms2.x;\r#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\r#else\nfloat h=randoms2.y*height.y;\rh=1.-h*h; \r#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\rlRadius=lRadius*h;\rfloat randX=lRadius*sin(s);\rfloat randZ=lRadius*cos(s);\rfloat randY=h *height.x;\rnewPosition=vec3(randX,randY,randZ); \rif (abs(cos(coneAngle))==1.0) {\rnewDirection=vec3(0.,1.0,0.);\r} else {\rvec3 randoms3=getRandomVec3(seed.z);\rnewDirection=normalize(newPosition+directionRandomizer*randoms3); \r}\r#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\routInitialPosition=initialPosition;\r#else \nnewPosition=vec3(0.,0.,0.);\rnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\r#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\r#ifdef LOCAL\noutPosition=newPosition;\r#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#ifndef BILLBOARD \noutInitialDirection=direction;\r#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\r#else \nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\r#endif\noutDirection=initial*power;\r#ifndef BILLBOARD \noutInitialDirection=initial;\r#endif\n#endif\n#ifdef ANIMATESHEET \noutCellIndex=cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\r#endif \n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif\n} else {\rfloat directionScale=timeDelta;\routAge=newAge;\rfloat ageGradient=newAge/life;\r#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient; \routInitialPosition=initialPosition;\r#else\noutPosition=position+direction*directionScale;\r#endif\noutLife=life;\routSeed=seed;\r#ifndef COLORGRADIENTS \noutColor=color;\r#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\routSize.yz=size.yz;\r#else\noutSize=size;\r#endif \n#ifndef BILLBOARD \noutInitialDirection=initialDirection;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#else\nvec3 updatedDirection=direction+gravity*timeDelta;\r#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\rfloat currentVelocity=length(updatedDirection);\rif (currentVelocity>limitVelocity) {\rupdatedDirection=updatedDirection*limitVelocityDamping;\r}\r#endif\noutDirection=updatedDirection;\r#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\rvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\routDirection=outDirection+force*timeDelta;\routNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\routAngle=angle+angularSpeed*timeDelta;\r#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\r#endif\n#ifdef ANIMATESHEET \nfloat offsetAge=outAge;\rfloat dist=cellInfos.y-cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\roffsetAge+=cellStartOffset;\r#else\nfloat cellStartOffset=0.;\r#endif \nfloat ratio=0.;\rif (cellInfos.w==1.0) {\rratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\r}\relse {\rratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);\r}\routCellIndex=float(int(cellInfos.x+ratio*dist));\r#endif\n}\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesVertexShader = { name, shader };\n"},"lineCount":null}},"error":null,"hash":"86a2df6811e0ac194d5860b3cb1a1b05","cacheData":{"env":{}}}