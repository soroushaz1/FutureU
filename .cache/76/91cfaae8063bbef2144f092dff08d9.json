{"id":"node_modules/@babylonjs/core/Shaders/screenSpaceReflection.fragment.js","dependencies":[{"name":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Shaders\\screenSpaceReflection.fragment.js.map","includedInParent":true,"mtime":1704105649902},{"name":"F:\\FutureU\\babylonjs\\package.json","includedInParent":true,"mtime":1704105536080},{"name":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\package.json","includedInParent":true,"mtime":1704105648327},{"name":"../Engines/shaderStore.js","loc":{"line":2,"column":28,"index":44},"parent":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Shaders\\screenSpaceReflection.fragment.js","resolved":"F:\\FutureU\\babylonjs\\node_modules\\@babylonjs\\core\\Engines\\shaderStore.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.screenSpaceReflectionPixelShader = void 0;\nvar _shaderStore = require(\"../Engines/shaderStore.js\");\n// Do not edit.\n\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\n#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\nuniform sampler2D normalSampler;\nuniform sampler2D positionSampler;\n#endif\nuniform mat4 view;\nuniform mat4 projection;\nuniform float stepSize;\nuniform float strength;\nuniform float threshold;\nuniform float roughnessFactor;\nuniform float reflectionSpecularFalloffExponent;\nvarying vec2 vUV;\n#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\nvec3 color;\nvec4 coords;\n};\n/**\n* According to specular,see https:\n*/\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\n{\nreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\n}\n/**\n* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\n* by sampling multiple reflection pixels.\n*/\nReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\ninfo.color=vec3(0.0);\nvec4 projectedCoord;\nfloat sampledDepth;\nfor(int i=0; i<SMOOTH_STEPS; i++)\n{\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\ndir*=0.5;\nif(depth>0.0)\nhitCoord-=dir;\nelse\nhitCoord+=dir;\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\n}\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.color/=float(SMOOTH_STEPS+1);\nreturn info;\n}\n/**\n* Tests the given world position (hitCoord) according to the given reflection vector (dir)\n* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\n*/\nReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\nvec4 projectedCoord;\nfloat sampledDepth;\ndir*=stepSize;\nfor(int i=0; i<REFLECTION_SAMPLES; i++)\n{\nhitCoord+=dir;\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\n#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\n#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\n{\n#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\n#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n#endif\n}\n}\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n}\nvec3 hash(vec3 a)\n{\na=fract(a*0.8);\na+=dot(a,a.yxz+19.19);\nreturn fract((a.xxy+a.yxx)*a.zyx);\n}\n#endif\nvoid main()\n{\n#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\nvec3 albedo=albedoFull.rgb;\nfloat spec=texture2D(reflectivitySampler,vUV).r;\nif (spec==0.0) {\ngl_FragColor=albedoFull;\nreturn;\n}\nvec3 normal=(texture2D(normalSampler,vUV)).xyz;\nvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\nvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\nfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\nvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\nReflectionInfo info=getReflectionInfo(jitt+reflected,position);\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\nfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\nvec3 F0=vec3(0.04);\nF0 =mix(F0,albedo,spec);\nvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\n#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\n#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\nfloat albedoMultiplier=1.0-reflectionMultiplier;\nvec3 SSR=info.color*fresnel;\ngl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n`;\n// Sideeffect\n_shaderStore.ShaderStore.ShadersStore[name] = shader;\n/** @internal */\nconst screenSpaceReflectionPixelShader = exports.screenSpaceReflectionPixelShader = {\n  name,\n  shader\n};"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":4}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":16}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":19}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":7,"column":26}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":10,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":4,"column":6},"generated":{"line":10,"column":6}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":4,"column":10},"generated":{"line":10,"column":10}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":10,"column":13}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":4,"column":47},"generated":{"line":10,"column":47}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":11,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":5,"column":6},"generated":{"line":11,"column":6}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":5,"column":12},"generated":{"line":11,"column":12}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":5,"column":15},"generated":{"line":11,"column":15}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":138,"column":1},"generated":{"line":144,"column":1}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":139,"column":0},"generated":{"line":145,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":0},"generated":{"line":146,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":11},"generated":{"line":146,"column":24}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":12},"generated":{"line":146,"column":25}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":24},"generated":{"line":146,"column":37}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":25},"generated":{"line":146,"column":38}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":29},"generated":{"line":146,"column":42}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":30},"generated":{"line":146,"column":43}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":33},"generated":{"line":146,"column":46}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":140,"column":39},"generated":{"line":146,"column":52}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":141,"column":0},"generated":{"line":147,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":7},"generated":{"line":148,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":13},"generated":{"line":148,"column":6}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":45},"generated":{"line":148,"column":38}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":45},"generated":{"line":148,"column":41}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":45},"generated":{"line":148,"column":48}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":45},"generated":{"line":148,"column":49}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":45},"generated":{"line":148,"column":81}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":48},"generated":{"line":148,"column":84}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":50},"generated":{"line":149,"column":2}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":54},"generated":{"line":149,"column":6}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":56},"generated":{"line":150,"column":2}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":62},"generated":{"line":151,"column":0}},{"source":"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts","name":null,"original":{"line":142,"column":64},"generated":{"line":151,"column":1}}],"sources":{"../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D positionSampler;\r#endif\nuniform mat4 view;\runiform mat4 projection;\runiform float stepSize;\runiform float strength;\runiform float threshold;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\rvec3 color;\rvec4 coords;\r};\r/**\r* According to specular,see https:\r*/\rvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\r/**\r* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\r* by sampling multiple reflection pixels.\r*/\rReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rinfo.color=vec3(0.0);\rvec4 projectedCoord;\rfloat sampledDepth;\rfor(int i=0; i<SMOOTH_STEPS; i++)\r{\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\rdir*=0.5;\rif(depth>0.0)\rhitCoord-=dir;\relse\rhitCoord+=dir;\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\r}\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.color/=float(SMOOTH_STEPS+1);\rreturn info;\r}\r/**\r* Tests the given world position (hitCoord) according to the given reflection vector (dir)\r* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\r*/\rReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rvec4 projectedCoord;\rfloat sampledDepth;\rdir*=stepSize;\rfor(int i=0; i<REFLECTION_SAMPLES; i++)\r{\rhitCoord+=dir;\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\r#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\r#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\r{\r#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\r#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r#endif\n}\r}\rinfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\rvec3 albedo=albedoFull.rgb;\rfloat spec=texture2D(reflectivitySampler,vUV).r;\rif (spec==0.0) {\rgl_FragColor=albedoFull;\rreturn;\r}\rvec3 normal=(texture2D(normalSampler,vUV)).xyz;\rvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\rvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\rfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\rvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\rReflectionInfo info=getReflectionInfo(jitt+reflected,position);\rvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\rfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\rvec3 F0=vec3(0.04);\rF0 =mix(F0,albedo,spec);\rvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\r#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\r#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\rfloat albedoMultiplier=1.0-reflectionMultiplier;\rvec3 SSR=info.color*fresnel;\rgl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\r#else\ngl_FragColor=texture2D(textureSampler,vUV);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflectionPixelShader = { name, shader };\n"},"lineCount":null}},"error":null,"hash":"91d92c21f83e25fe490bc824410ce13b","cacheData":{"env":{}}}